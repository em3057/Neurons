<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">

<style>

.node {
  stroke: none;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
  marker-end: url(#arrow-marker);
}



</style>
<title>SNN</title>
<xscript src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.14/d3.min.js"></xscript>
<script src="/d3.min.js"></script>
</head>
<body>

<canvas id="chart" width="1200" height="250"></canvas>

	<script type="text/javascript" charset="utf-8">
	var width = 1200,
    height = 650;

var color = d3.scaleOrdinal( d3.schemeCategory20b ) ;

var force = d3.forceSimulation()
    .linkDistance(350)
    .charge(-800)
    .friction(.1)
    .gravity( .2 ) 
    .size([width, height]);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var marker = svg.append( "marker" )
.attr( "id", "arrow-marker" )
.attr( "markerWidth", "50"  ) 
.attr( "markerHeight", "50" )  
.attr( "refX", "15"  ) 
.attr( "refY", "3" ) 
.attr( "orient", "auto" ) 
.attr( "markerUnits", "userSpaceOnUse" ) ;

marker.append( "path" )
.attr( "d", "M0,0 L0,6 L9,3 z" )
.style( {fill: "#000000" } ) ;

d3.json("data", function(error, graph) {
  if (error) return console.warn(error);

  force
      .nodes(graph.nodes)
      .links(graph.links)
      .start();
      
  var link = svg.selectAll(".link")
      .data(graph.links)
	.enter().append("line")
      .attr("class", "link") ;

  var node = svg.selectAll(".node")
      .data(graph.nodes)
    .enter().append("polygon")
      .attr("id", function(d) { 
      		return "NEURON" + d.index ;
      		} )
      .attr("class", "node")
      .attr("points", function(d) { 
      		if( d.type=='OUTPUT' ) return "-0.83,-11.67 -8.17,11.67 11.83,-4.33 -11.83,-4.33 6.50,11.67" ;  // star
      		if( d.type=='INPUT' ) return "-10.00,-8.75 -10.00,8.75 10.00,-6.25" ;  // triangle
      		return "-4,-4 4,-4 4,4 -4,4" ;  // square
      	})
      .style("fill", function(d) { 
    	  return color(d.potential / 5.0) ; 
    	})
      .call(force.drag);

  node.append("title")
      .text(function(d) { return d.name; });

  force.on("tick", function() {
     link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node.attr("transform", function(d) { return "translate(" + d.x+ "," + d.y + ")"; })
        
  });
});
</script>

		
<script>
var c = document.getElementById("chart");
var ctx = c.getContext("2d");
ctx.fillStyle = "#FF0000";

var ws = null ;
var intervalTimer = null ;

function resetWebSocket() {
	ws = new WebSocket( "ws://localhost:8111/live" ) ;
	clearInterval( intervalTimer ) ;
	
	// called when socket connection established
	ws.onopen = function() {
    	console.log("Connected.")
	};
 
	const history = []
	const HistoryLength = 100 ;
	
	// called when a message received from server
	ws.onmessage = function (evt) {
		var data = JSON.parse( evt.data ) ;
		for( var i=0 ; i<data.potentials.length ; i++ ) {
			var n = document.getElementById( "NEURON" + i ) ;
			if( n ) {
				n.style.fill = color( data.potentials[i] ) ; 
			}
		}
		c.width = c.width;		
		
		history.push( data.outputs ) ;
		if( history.length > HistoryLength ) history.shift() ;
		const cols = [ '#0000ff', '#00ff00', '#ff0000', '#000000', '#ffff00', '#00ffff' ]
		for( var h=0 ; h<data.outputs.length ; h++ ) {
			ctx.beginPath() ;
			ctx.moveTo( 0, 125 );
			for( var i=0 ; i<history.length ; i++ ) {
				ctx.lineTo( i*12, 125-(125*history[i][h]) ) ;
			}
			ctx.strokeStyle = cols[h] ;
			ctx.stroke();
		}
	};
	 
	// called when socket connection closed
	ws.onclose = function() {
	    console.log("Disconnected")
	    intervalTimer = setInterval( resetWebSocket, 1000 ) ;
	};
	 
	// called in case of an error
	ws.onerror = function(err) {
	    console.log("ERROR!", err )
	};
	
}

intervalTimer = setInterval( resetWebSocket, 1000 ) ;

 
// sends msg to the server over websocket
function sendToServer(msg) {
	if( ws ) ws.send(msg);
}		

		
		</script>
</body>
</html>