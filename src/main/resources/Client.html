<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">

<style>

.node {
  stroke: none;
}
.activated {
  stroke: none;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
  marker-end: url(#arrow-marker);
}
.inhibitor {
  stroke: #D11C1C;
}
.status {
	position: absolute ;
	top: 0 ;
	left: 0 ;
	margin: 5px ;
}
</style>
<title>SNN</title>
<script src="/d3.min.js"></script>
</head>
<body>
<div class="status"></div>

<canvas id="chart" width="1200" height="125"></canvas>
<script type="text/javascript" charset="utf-8">
	var width = 700;
    var height = 450;

	const color = d3.scaleOrdinal( d3.schemeCategory20 ) ;

	var svg = d3.select("body").append("svg")
		.attr("width", width)
		.attr("height", height);

	var marker = svg.append( "marker" )
	.attr( "id", "arrow-marker" )
	.attr( "markerWidth", "50"  ) 
	.attr( "markerHeight", "50" )  
	.attr( "refX", "15"  ) 
	.attr( "refY", "3" ) 
	.attr( "orient", "auto" ) 
	.attr( "markerUnits", "userSpaceOnUse" ) ;

	marker.append( "path" )
	.attr( "d", "M0,0 L0,6 L9,3 z" )
	.style( {fill: "#000000" } ) ;

d3.json("data", function(error, graph) {
  if (error) return console.warn(error);

	function dragstarted(d) {
		if (!d3.event.active) simulation.alphaTarget(0.3).restart();
		d.fx = d.x;
		d.fy = d.y;
	}

	function dragged(d) {
		d.fx = d3.event.x;
		d.fy = d3.event.y;
	}

	function dragended(d) {
		if (!d3.event.active) simulation.alphaTarget(0);
		d.fx = null;
		d.fy = null;
	}


	const links = svg
	    .selectAll("line")
    	.data(graph.links)
    	.enter().append("line") 
		.attr( 'class', 'link' )
		.attr( 'class', function(l) { 
			return l.weight>0 ? 'link' : 'link inhibitor' ; 
		 	} )
		;

  	const nodes = svg
    	.selectAll("circle.node")
    	.data( graph.nodes )
    	.enter().append("circle")
			.attr( 'class', 'node' )
			.attr( 'id', function(d) { return d.name } )
      		.attr("r", function(d) { return 6.5 } ) 
      		.attr("fill", function(d) { return color( d.type ); })
      		.call(d3.drag()
          		.on("start", dragstarted)
          		.on("drag", dragged)
          		.on("end", dragended)) 
  		;


  function tick() {
    	nodes
    	.attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; })
    	;
    
    	links
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; })
    	;
	}

  const simulation = d3.forceSimulation()
	.nodes( graph.nodes ) 	
	.force( "link", d3.forceLink()
	 		.strength( function(l) { return .1 ; }) 
	 		.distance( function(l) { return 10 ; } )
	 		.id( function(n) { return n.name ; } ) 
	 		.links( graph.links ) 
	 	)
	.force( "charge", d3.forceManyBody()
			.strength( -20 ) 
		)
	.force( "center", d3.forceCenter(width/2, height/2) )
	.force( "collide", d3.forceCollide( 15 ) ) 
	//.force( "x",  d3.forceX().x( function(d) { return (d.px || 3) * 100 - 200 ; } ) ) 
	.force( "y",  d3.forceX().x( function(d) { return (d.py || 3) * 100 - 200 ; } ) ) 
	.on("tick", tick ) 
	.on("end", tick ) 
	;
});
</script>

		
<script>
var c = document.getElementById("chart");
var ctx = c.getContext("2d");
ctx.fillStyle = "#FF0000";

var ws = null ;
var intervalTimer = null ;

function resetWebSocket() {
	ws = new WebSocket( "ws://localhost:8111/live" ) ;
	clearInterval( intervalTimer ) ;
	
	// called when socket connection established
	ws.onopen = function() {
    	console.log("Connected.")
	};
 
	const history = []
	const HistoryLength = 100 ;
	
	// called when a message received from server
	ws.onmessage = function (evt) {
		var data = JSON.parse( evt.data ) ;
		const status = document.querySelector( ".status" ) ;
		status.textContent = "Score: " + data.score.toFixed(3) ;
		for( var i=0 ; i<data.states.length ; i++ ) {			
			var n = document.getElementById( data.states[i].name ) ;
			if( n ) {				
				n.style.fill = color( data.states[i].potential > 0.3 ? 1.0 : 10 ) ; 
			}
		}
		c.width = c.width;		
		
		history.push( data.outputs ) ;
		if( history.length > HistoryLength ) history.shift() ;
		const cols = [ '#0000ff', '#00ff00', '#ff0000', '#000000', '#ffff00', '#00ffff' ]
		for( var h=0 ; h<data.outputs.length ; h++ ) {
			ctx.beginPath() ;
			ctx.moveTo( 0, 100 );
			for( var i=0 ; i<history.length ; i++ ) {
				ctx.lineTo( i*12, 100-(100*history[i][h]) ) ;
			}
			ctx.strokeStyle = cols[h] ;
			ctx.stroke();
		}
	};
	 
	// called when socket connection closed
	ws.onclose = function() {
	    console.log("Disconnected")
	    intervalTimer = setInterval( resetWebSocket, 1000 ) ;
	};
	 
	// called in case of an error
	ws.onerror = function(err) {
	    console.log("ERROR!", err )
	};
	
}

intervalTimer = setInterval( resetWebSocket, 1000 ) ;

 
// sends msg to the server over websocket
function sendToServer(msg) {
	if( ws ) ws.send(msg);
}		

		
		</script>
</body>
</html>