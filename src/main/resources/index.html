<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">

<style>
body {
	background-color: #201713 ;
}
.node {
	stroke: none;
	font-size: 8pt ;
	font-family: Arial, Helvetica, sans-serif ;
}
.potential {
	fill: #80a0c0 ;
}
.activated {
  stroke: none;
}

.link {
  stroke: #ccc;
  stroke-opacity: .6;
  marker-end: url(#arrow-marker);
}
.inhibitor {
  stroke: #800030;
}
.status {
	position: absolute ;
	top: 0 ;
	left: 0 ;
	margin: 5px ;
}
.fill-blotter {
	left: 0 ;
	top: 0 ;
	width: 100% ;
	height: 120px ;
	border: none ;
	padding: 0 ;
	xbackground-color: #050225 ;
	overflow: hidden ;
}
.liquid {
	position: absolute ;
	left: 0 ;
	top: 120px ;
	width: 100% ;
	bottom: 0 ;
	border: none ;
	padding: 0 ;
	background-color: #050225 ;
	overflow: hidden ;
}

</style>
<title>SNN</title>
<script src="/d3.min.js"></script>
</head>
<body>
<div class="status"></div>

<canvas id="chart" class='fill-blotter' width='1200' height='150'></canvas>
<div id='liquid' class='liquid'></div>

<script type="text/javascript" charset="utf-8">
	var width = 800;
    var height = 600;

	const color = d3.scaleOrdinal( d3.schemeCategory20 ) ;

	var svg = d3.select("#liquid").append("svg") 
		.attr("width", '100%')
		.attr("height", '100%')
		.attr("viewBox", "0 0 800 600")

	const width2 = svg.width ;
	
	var marker = svg.append( "marker" )
	.attr( "id", "arrow-marker" )
	.attr( "markerWidth", "50"  ) 
	.attr( "markerHeight", "50" )  
	.attr( "refX", "15"  ) 
	.attr( "refY", "3" ) 
	.attr( "orient", "auto" ) 
	.attr( "markerUnits", "userSpaceOnUse" ) ;

	marker.append( "path" )
	.attr( "d", "M0,0 L0,6 L9,3 z" )
	.attr( "fill", "#aaa"  ) ;

d3.json("data", function(error, graph) {
  if (error) return console.warn(error);

	function dragstarted(d) {
		if (!d3.event.active) simulation.alphaTarget(0.3).restart();
		d.fx = d.x;
		d.fy = d.y;
	}

	function dragged(d) {
		d.fx = d3.event.x;
		d.fy = d3.event.y;
	}

	function dragended(d) {
		if (!d3.event.active) simulation.alphaTarget(0);
		d.fx = null;
		d.fy = null;
	}


	const links = svg
	    .selectAll("line")
    	.data(graph.links)
    	.enter().append("line") 
		.attr( 'class', 'link' )
		.attr( 'class', function(l) { 
			return l.weight>0 ? 'link' : 'link inhibitor' ; 
		 	} )
		;

		const nodes = svg
    	.selectAll("circle.node")
    	.data( graph.nodes )
    	.enter()
			.append("circle")
				.attr( 'class', 'node' )
				.attr( 'id', function(d) { return d.name } )
				.attr("r", function(d) { return 6.5 } ) 
				.attr("fill", function(d) { return color( d.type ); })
				.call(d3.drag()
					.on("start", dragstarted)
					.on("drag", dragged)
					.on("end", dragended)) 
  		;

		const texts = svg
    	.selectAll("text.potential")
    	.data( graph.nodes )
		.enter()
			.append( 'text' )
				.attr( 'class', 'potential' )
				.attr( 'font-size', '9pt')
				.attr( 'font-family', 'arial')
				.attr( 'id', function(d) { return 'txt-' + d.name } )
				.text( "0.00" )
  		;


  function tick() {
		nodes
		.attr("cx", function(d) { return d.x; })
		.attr("cy", function(d) { return d.y; })
		;
		texts
    	.attr("x", function(d) { return d.x; })
        .attr("y", function(d) { return d.y; })
    	;

    	links
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; })
    	;
	}

  const simulation = d3.forceSimulation()
	.nodes( graph.nodes ) 	
	.force( "link", d3.forceLink()
	 		.strength( function(l) { return .2 ; }) 
	 		.distance( function(l) { return 15 ; } )
	 		.id( function(n) { return n.name ; } ) 
	 		.links( graph.links ) 
	 	)
	.force( "charge", d3.forceManyBody()
			.strength( -30 ) 
		)
	.force( "center", d3.forceCenter(width/2, height/2) )
	.force( "collide", d3.forceCollide( 40 ) ) 
	//.force( "x",  d3.forceX().x( function(d) { return (d.px || 3) * 100 - 200 ; } ) ) 
	.force( "y",  d3.forceX().x( function(d) { return (d.py || 3) * 100 - 200 ; } ) ) 
	.on("tick", tick ) 
	.on("end", tick ) 
	;
});
</script>

		
<script>
var c = document.getElementById("chart");
var ctx = c.getContext("2d");
ctx.fillStyle = "#FF0000";

var ws = null ;
var intervalTimer = null ;

function resetWebSocket() {
	ws = new WebSocket( "ws://localhost:8111/live" ) ;
	clearInterval( intervalTimer ) ;
	
	// called when socket connection established
	ws.onopen = function() {
    	console.log("Connected.")
	};
 
	const history = []
	const HistoryLength = 100 ;
	
	// called when a message received from server
	ws.onmessage = function (evt) {
		var data = JSON.parse( evt.data ) ;
		const status = document.querySelector( ".status" ) ;
		status.textContent = "Score: " + data.score.toFixed(3) ;
		for( var i=0 ; i<data.states.length ; i++ ) {			
			var n = document.getElementById( data.states[i].name ) ;
			if( n ) {				
				n.style.fill = color( data.states[i].potential * 10 ) ; 
				// n.style.fill = color( data.states[i].potential > 0.3 ? 1.0 : 10 ) ; 
			}
			var n = document.getElementById( 'txt-' + data.states[i].name ) ;
			if( n ) {				
				n.textContent = data.states[i].potential.toFixed(2) ; 
			}

		}
		c.width = c.width;		
		
		history.push( data.outputs ) ;
		if( history.length > HistoryLength ) history.shift() ;
		const cols = [ '#ff00ff', '#ffff00', '#00ffff', '#ffffff', '#c0c0c0' ]
		for( var h=0 ; h<data.outputs.length ; h++ ) {
			ctx.beginPath() ;
			ctx.moveTo( 0, 100 );
			for( var i=0 ; i<history.length ; i++ ) {
				ctx.lineTo( i*12, 100-(100*history[i][h]) ) ;
			}
			ctx.strokeStyle = cols[h] ;
			ctx.stroke();
		}
	};
	 
	// called when socket connection closed
	ws.onclose = function() {
	    console.log("Disconnected")
	    intervalTimer = setInterval( resetWebSocket, 1000 ) ;
	};
	 
	// called in case of an error
	ws.onerror = function(err) {
	    console.log("ERROR!", err )
	};
	
}

intervalTimer = setInterval( resetWebSocket, 1000 ) ;

 
// sends msg to the server over websocket
function sendToServer(msg) {
	if( ws ) ws.send(msg);
}		

		
		</script>
</body>
</html>